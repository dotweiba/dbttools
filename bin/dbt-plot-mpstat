#!/usr/bin/env python

#
# This file is released under the terms of the Artistic License.
# Please see the file LICENSE, included in this package, for details.
#
# Copyright (C) 2006-2010 Mark Wong
#

import sys
from os import system
from os.path import basename, exists, realpath
from re import sub

import rpy2.robjects as robjects
from rpy2.robjects.vectors import DataFrame

r = robjects.r

# R can only handle pch from 1-25.  Use modulo to recycle and reuse the
# symbols.
max_pch = 25


def get_legend(data):
    names = list()
    for col in sorted(data):
        names.append(col)
    return names


def gety(df, data):
    y = list()
    for col in sorted(data):
        y.append(df.rx2(col))
    return y


def getymax(df, data):
    y = list()
    for col in sorted(data):
        y.append(df.rx(col))
    return y


def make_chart(tag, x, y, xmax, ymax_list, num_colors, title, ylabel, legend):
    r.bitmap('%s/mpstat-%s.png' % (outputdir, tag), type='png16m', units='px',
             width=1280, height=800, res=150, taa=4, gaa=4)

    color = r.rainbow(num_colors)
    ymax = r.max(*ymax_list)[0]

    # Plot the first set of data.
    r.plot(x, y[0], xlim=r.c(0, xmax), ylim=r.c(0, ymax), type='b',
           main=title, xlab='Elapsed Time (minutes)', ylab=ylabel, pch=1,
           col=color[0])

    # Plot the rest of the data.
    y.pop(0)
    index = 1
    pch = 2
    for i in y:
        r.points(x, y=i, type='b', pch=pch, col=color[index])

        index += 1
        pch = pch % max_pch + 1

    # Create a legend if there are any labels.
    int_list = list()
    pch = 1
    for i in legend:
        int_list.append(pch)
        pch = pch % max_pch + 1
    if len(legend) > 0:
        r.legend('topright', r.c(*legend), pch=r.c(*int_list), col=color)

    r.grid(col='gray')
    r('dev.off()')


def prep_data_frame(data):
    for key, value in data.iteritems():
        data[key] = robjects.FloatVector(value)
    return data


argc = len(sys.argv)
if argc != 3:
    print 'Create plots from mpstat output.'
    print 'usage: %s <mpstat.out> <outputdir>' % sys.argv[0]
    print
    print '    <mpstat.out> - full path to the mpstat.out file'
    print '    <output directory> - location to write output files'
    print
    print 'Will attempt to create <output directory> if it does not exist.'
    sys.exit(1)

infilename = sys.argv[1]
outputdir = sys.argv[2]

# Make sure we can oping the file to read in data.
try:
    f = open(infilename, 'r')
except:
    print 'cannot open file: %s' % infilename
    sys.exit(1)

# Make sure we can open the files to write to.

if not exists(outputdir):
    try:
        # FIXME: Like I know why makedirs() fails...
        #makedirs(outputdir)
        system('mkdir -p %s' % outputdir)
    except:
        print 'cannot create directory "%s"' % outputdir
        sys.exit(2)

outputdir = realpath(outputdir)

# First identify the format.
format = 0
for line in f:
    c = line.strip().split()

    if len(c) == 11 and c[1] == 'CPU':
        # HH:MM:SS CPU %usr %nice %sys %iowait %irq %soft %steal %guest %idle
        format = 1
        break
    elif len(c) == 12 and c[2] == 'CPU':
        # HH:MM:SS AM CPU %user %nice %sys %iowait %irq %soft %steal %idle
        # intr/s
        # RHEL 5.5
        format = 2
        break

if format == 0:
    print 'unrecognized mpstat format, exiting...'
    sys.exit(1)

if format == 1:
    cnum = 11
    c_processor = 1
    c_user = 2
    c_nice = 3
    c_sys = 4
    c_iowait = 5
    c_irq = 6
    c_soft = 7
    c_steal = 8
    c_idle = 9
    c_intrs = 10
elif format == 2:
    cnum = 12
    c_processor = 2
    c_user = 3
    c_nice = 4
    c_sys = 5
    c_iowait = 6
    c_irq = 7
    c_soft = 8
    c_steal = 9
    c_idle = 10
    c_intrs = 11

# Read in the file and build up the dictionaries for each column of data from
# mpstat.

# mpstat waits the first sample length before outputting data.  Prepends 0's
# for the first datapoint.
d_x = [0, 1]
d_user = dict()
d_nice = dict()
d_sys = dict()
d_iowait = dict()
d_irq = dict()
d_soft = dict()
d_steal = dict()
d_idle = dict()
d_intrs = dict()

# Build a dict of dicts.

count = 1
for line in f:
    c = line.split()

    if len(c) != cnum:
        continue

    if c[c_processor] == 'CPU':
        count += 1
        d_x.append(count)
        continue

    if c[c_processor] != 'all':
        processor = 'p%02d' % int(c[c_processor])
    else:
        processor = c[c_processor]

    if processor not in d_user:
        d_user[processor] = [0]
        d_nice[processor] = [0]
        d_sys[processor] = [0]
        d_iowait[processor] = [0]
        d_irq[processor] = [0]
        d_soft[processor] = [0]
        d_steal[processor] = [0]
        d_idle[processor] = [0]
        d_intrs[processor] = [0]

    d_user[processor].append(float(c[c_user]))
    d_nice[processor].append(float(c[c_nice]))
    d_sys[processor].append(float(c[c_sys]))
    d_iowait[processor].append(float(c[c_iowait]))
    d_irq[processor].append(float(c[c_irq]))
    d_soft[processor].append(float(c[c_soft]))
    d_steal[processor].append(float(c[c_steal]))
    d_idle[processor].append(float(c[c_idle]))
    d_intrs[processor].append(float(c[c_intrs]))
f.close()

# Create the R data frames.

data = {'elapsed_time': robjects.IntVector(d_x)}
dfx = r['data.frame'](**data)

xmax = r.max(*dfx.rx('elapsed_time'))[0]

legend = get_legend(d_user)

d_user = prep_data_frame(d_user)
df = r['data.frame'](**d_user)
y = gety(df, d_user)
make_chart('user', dfx.rx2('elapsed_time'), y, xmax, [100], len(y),
           'User Utilization', 'Percentage', legend)

d_nice = prep_data_frame(d_nice)
df = r['data.frame'](**d_nice)
y = gety(df, d_nice)
make_chart('nice', dfx.rx2('elapsed_time'), y, xmax, [100], len(y),
           'Nice Utilization', 'Percentage', legend)

d_sys = prep_data_frame(d_sys)
df = r['data.frame'](**d_sys)
y = gety(df, d_sys)
make_chart('sys', dfx.rx2('elapsed_time'), y, xmax, [100], len(y),
           'System Utilization', 'Percentage', legend)

d_iowait = prep_data_frame(d_iowait)
df = r['data.frame'](**d_iowait)
y = gety(df, d_iowait)
make_chart('iowait', dfx.rx2('elapsed_time'), y, xmax, [100], len(y),
           'I/O Wait Utilization', 'Percentage', legend)

d_irq = prep_data_frame(d_irq)
df = r['data.frame'](**d_irq)
y = gety(df, d_irq)
make_chart('irq', dfx.rx2('elapsed_time'), y, xmax, [100], len(y),
           'Interrupt Utilization', 'Percentage', legend)

d_soft = prep_data_frame(d_soft)
df = r['data.frame'](**d_soft)
y = gety(df, d_soft)
make_chart('soft', dfx.rx2('elapsed_time'), y, xmax, [100], len(y),
           'Soft Interrupt Utilization', 'Percentage', legend)

#d_steal = prep_data_frame(d_steal)
#df = r['data.frame'](**d_steal)
#y = gety(df, d_steal)
#make_chart('steal', dfx.rx2('elapsed_time'), y, xmax, [100], len(y),
#           'Stolen Utilization', 'Percentage', legend)

d_idle = prep_data_frame(d_idle)
df = r['data.frame'](**d_idle)
y = gety(df, d_idle)
make_chart('idle', dfx.rx2('elapsed_time'), y, xmax, [100], len(y),
           'Idle Utilization', 'Percentage', legend)

d_intrs = prep_data_frame(d_intrs)
df = r['data.frame'](**d_intrs)
y = gety(df, d_intrs)
ymax_list = getymax(df, d_intrs)
make_chart('intrs', dfx.rx2('elapsed_time'), y, xmax, ymax_list, len(y),
           'Interrupts Received', 'Interrupts per Second', legend)
