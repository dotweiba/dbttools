#!/usr/bin/env python

#
# This file is released under the terms of the Artistic License.
# Please see the file LICENSE, included in this package, for details.
#
# Copyright (C) 2006-2010 Mark Wong
#

import sys
from os import system
from os.path import basename, exists, realpath
from re import sub


def get_r_ymax(dlist, tag):
    index = 0
    first = True
    for d in dlist:
        for key, junk in sorted(d.iteritems()):
            if first == True:
                ymax = 'd%s$%s' % (tag[index], key)
                first = False
            else:
                ymax += ', d%s$%s' % (tag[index], key)
        index += 1
    return ymax


def parse_format(f, dir, format, sample):

    if format == 1:
        cnum = 11
        c_processor = 1
        c_user = 2
        c_nice = 3
        c_sys = 4
        c_iowait = 5
        c_irq = 6
        c_soft = 7
        c_steal = 8
        c_idle = 9
        c_intrs = 10
    elif format == 2:
        cnum = 12
        c_processor = 2
        c_user = 3
        c_nice = 4
        c_sys = 5
        c_iowait = 6
        c_irq = 7
        c_soft = 8
        c_steal = 9
        c_idle = 10
        c_intrs = 11

    # Read in the file and build up the dictionaries for each column of data
    # from mpstat.

    d_user = dict()
    d_nice = dict()
    d_sys = dict()
    d_iowait = dict()
    d_irq = dict()
    d_soft = dict()
    d_steal = dict()
    d_idle = dict()
    d_intrs = dict()

    # Build a dict of dicts.

    count = 0
    for line in f:
        c = line.split()

        if len(c) != cnum:
            continue

        if c[c_processor] == 'CPU':
            count += 1
            continue

        if c[c_processor] != 'all':
            processor = 'p%02d' % int(c[c_processor])
        else:
            processor = c[c_processor]

        try:
            d_user[processor][count] = c[c_user]
        except:
            d_user[processor] = dict()
            d_user[processor][count] = c[c_user]
            d_nice[processor] = dict()
            d_sys[processor] = dict()
            d_iowait[processor] = dict()
            d_irq[processor] = dict()
            d_soft[processor] = dict()
            d_steal[processor] = dict()
            d_idle[processor] = dict()
            d_intrs[processor] = dict()
        d_nice[processor][count] = c[c_nice]
        d_sys[processor][count] = c[c_sys]
        d_iowait[processor][count] = c[c_iowait]
        d_irq[processor][count] = c[c_irq]
        d_soft[processor][count] = c[c_soft]
        d_steal[processor][count] = c[c_steal]
        d_idle[processor][count] = c[c_idle]
        d_intrs[processor][count] = c[c_intrs]
    f.close()

    write_data_file('user', d_user, dir, count, sample)
    write_data_file('nice', d_nice, dir, count, sample)
    write_data_file('sys', d_sys, dir, count, sample)
    write_data_file('iowait', d_iowait, dir, count, sample)
    write_data_file('irq', d_irq, dir, count, sample)
    write_data_file('soft', d_soft, dir, count, sample)
    write_data_file('steal', d_steal, dir, count, sample)
    write_data_file('idle', d_idle, dir, count, sample)
    write_data_file('intrs', d_intrs, dir, count, sample)

    # Done reading the input file, now generate the data files for R.
    rfile = 'mpstat.r'
    outfile = '%s/%s' % (dir, rfile)
    try:
        r = open(outfile, 'w')
    except:
        print 'cannot open file for writing: ' + outfile
        sys.exit(1)

    for tag in ['user', 'nice', 'sys', 'iowait', 'irq', 'soft', 'steal',
            'idle', 'intrs' ]:
        r.write('d%s <- read.table("mpstat-%s.data", header = TRUE)\n' % \
                (tag, tag))

    write_r_format_1(r, 'user', 'User Utilization', 'user', d_user, count,
            'Percentage', '100')
    write_r_legend(r, [d_user], [''])

    write_r_format_1(r, 'nice', 'Nice Utilization', 'nice', d_nice, count,
            'Percentage', '100')
    write_r_legend(r, [d_nice], [''])

    write_r_format_1(r, 'sys', 'System Utilization', 'sys', d_sys, count,
            'Percentage', '100')
    write_r_legend(r, [d_sys], [''])

    write_r_format_1(r, 'iowait', 'I/O Wait Utilization', 'iowait', d_iowait,
            count, 'Percentage', '100')
    write_r_legend(r, [d_iowait], [''])

    write_r_format_1(r, 'irq', 'IRQ Utilization', 'irq', d_irq, count,
            'Percentage', '100')
    write_r_legend(r, [d_irq], [''])

    write_r_format_1(r, 'soft', 'Soft Utilization', 'soft', d_soft, count,
            'Percentage', '100')
    write_r_legend(r, [d_soft], [''])

    write_r_format_1(r, 'steal', 'Involuntary Utilization', 'steal', d_steal,
            count, 'Percentage', '100')
    write_r_legend(r, [d_steal], [''])

    write_r_format_1(r, 'idle', 'idle', 'idle', d_idle, count, 'Percentage',
            '100')
    write_r_legend(r, [d_idle], [''])

    ymax = get_r_ymax([d_intrs], ['intrs'])
    write_r_format_1(r, 'intrs', 'Interrupts Received', 'intrs', d_intrs,
            count, 'Interrupts per Second', ymax)
    write_r_legend(r, [d_intrs], ['intrs'])

    r.write('dev.off()\n')

    r.close()

    system('(cd %s && R --slave --no-save < %s)' % (dir, rfile))


# Create the data files for R.
def write_data_file(tag, d, dir, count, sample):
    datafilename = 'mpstat-%s.data' % tag
    outfile = dir + '/' + datafilename
    try:
        f = open(outfile, 'w')
    except:
        print 'cannot open file for writing: ' + outfile
        sys.exit(1)

    # Generate the header.
    header = 'count'
    # FIXME: Do I really have to use a junk variable to ignore stuff?
    for key, junk in sorted(d.iteritems()):
        header += ' %s' % key
    f.write(header + '\n')

    # Output the data.  Start at 1 instead of 0 because
    for i in range(0, count - 1):
        line = '%d' % (i * sample)
        for key, v in sorted(d.iteritems()):
            # FIXME: Need to handle if that device or iteration doesn't exist.
            line += ' %s' % v[i]
        f.write(line + '\n')
    f.close()


def write_r_format_1(r, name, title, tag, d, count, ylab, ymax):
    processor_count = len(d)

    r.write('\n')
    r.write('max_x <-max(c(d%s$count))\n' % tag)
    r.write('max_y <-max(%s)\n' % ymax)
    r.write('bitmap("mpstat-%s.png",\n' \
            '       type = "png16m",\n' \
            '       units = "px",\n' \
            '       width = 1280,\n' \
            '       height = 800,\n' \
            '       taa = 4,\n' \
            '       gaa = 4)\n' % name)
    r.write('color <- rainbow(%d)\n' % processor_count)
    first = True
    i = 1
    # FIXME: Do I really have to use a junk variable to ignore stuff?
    legend = ''
    for key, junk in sorted(d.iteritems()):
        if first:
            r.write('plot(d%s$count,\n' % tag)
            r.write('    y = d%s$%s,\n' % (tag, key))
            r.write('    type = "b",\n')
            r.write('    col = color[1],\n')
            r.write('    pch = 1,\n')
            r.write('    main = "%s",\n' % title)
            r.write('    xlab = "Elapsed Time (Minutes)",\n')
            r.write('    ylab = "%s",\n' % ylab)
            r.write('    ylim = c(0, max_y))\n')
            first = False
        else:
            r.write('points(d%s$count, d%s$%s, type = "b", ' \
                    'col = color[%d], pch = %d)\n' % (tag, tag, key, i, i))
        i += 1
    r.write('grid()\n')


def write_r_legend(r, dlist, tag):
    count = 0
    first = True
    legend = ''
    index = 0
    for d in dlist:
        for key, junk in sorted(d.iteritems()):
            if first == True:
                legend = '"%s %s"' % (key, tag[index])
                first = False;
            else:
                legend += ', "%s %s"' % (key, tag[index])
            count += 1
        index += 1
    r.write('legend("topright", c(%s), pch = 1:%d, col = color)\n' % \
            (legend, count))


argc = len(sys.argv)
if argc != 3:
    print 'Create plots from mpstat output.'
    print 'usage: %s <mpstat.out> <outputdir>' % sys.argv[0]
    print
    print '    <mpstat.out> - full path to the mpstat.out file'
    print '    <output directory> - location to write output files'
    print
    print 'Will attempt to create <output directory> if it does not exist.'
    sys.exit(1)

infilename = sys.argv[1]
outputdir = sys.argv[2]

# Make sure we can oping the file to read in data.
try:
    f = open(infilename, 'r')
except:
    print 'cannot open file: %s' % infilename
    sys.exit(1)

# Make sure we can open the files to write to.

if not exists(outputdir):
    try:
        # FIXME: Like I know why makedirs() fails...
        #makedirs(outputdir)
        system('mkdir -p %s' % outputdir)
    except:
        print 'cannot create directory "%s"' % outputdir
        sys.exit(2)

outputdir = realpath(outputdir)

# First identify the format.
format = 0
for line in f:
    c = line.strip().split()

    if len(c) == 11 and c[1] == 'CPU':
        # HH:MM:SS CPU %usr %nice %sys %iowait %irq %soft %steal %guest %idle
        format = 1
        break
    elif len(c) == 12 and c[2] == 'CPU':
        # HH:MM:SS AM CPU %user %nice %sys %iowait %irq %soft %steal %idle
        # intr/s
        # RHEL 5.5
        format = 2
        break

if format == 0:
    print 'unrecognized mpstat format, exiting...'
    sys.exit(1)

parse_format(f, outputdir, format, 60)
