#!/usr/bin/env python

#
# This file is released under the terms of the Artistic License.
# Please see the file LICENSE, included in this package, for details.
#
# Copyright (C) 2006-2010 Mark Wong
#

import sys
from os import system
from os.path import basename, exists, realpath
from re import sub

import rpy2.robjects as robjects
from rpy2.robjects.vectors import DataFrame

r = robjects.r

# R can only handle pch from 1-25.  Use modulo to recycle and reuse the
# symbols.
max_pch = 25


def get_legend(data):
    names = list()
    for col in sorted(data):
        names.append(col)
    return names


def gety(df, data):
    y = list()
    for col in sorted(data):
        y.append(df.rx2(col))
    return y


def getymax(df, data):
    y = list()
    for col in sorted(data):
        y.append(df.rx(col))
    return y


def make_chart(tag, x, y, xmax, ymax_list, num_colors, title, ylabel, legend):
    r.bitmap('%s/iostat-%s.png' % (outputdir, tag), type='png16m', units='px',
             width=1280, height=800, res=150, taa=4, gaa=4)

    color = r.rainbow(num_colors)
    ymax = r.max(*ymax_list)[0]

    # Plot the first set of data.
    r.plot(x, y[0], xlim=r.c(0, xmax), ylim=r.c(0, ymax), type='b',
           main=title, xlab='Elapsed Time (minutes)', ylab=ylabel, pch=1,
           col=color[0])

    # Plot the rest of the data.
    y.pop(0)
    index = 1
    pch = 2
    for i in y:
        r.points(x, y=i, type='b', pch=pch, col=color[index])

        index += 1
        pch = pch % max_pch + 1

    # Create a legend if there are any labels.
    int_list = list()
    pch = 1
    for i in legend:
        int_list.append(pch)
        pch = pch % max_pch + 1
    if len(legend) > 0:
        r.legend('topright', r.c(*legend), pch=r.c(*int_list), col=color)

    r.grid(col='gray')
    r('dev.off()')


def prep_data_frame(data):
    for key, value in data.iteritems():
        data[key] = robjects.FloatVector(value)
    return data


argc = len(sys.argv)
if argc != 3 and argc != 4:
    print 'Create plots from iostat output.'
    print 'usage: %s <iostat.out> <outputdir> [devices]' % sys.argv[0]
    print
    print '    <iostat.out> - full path to the iostat.out file'
    print '    <output directory> - location to write output files'
    print '    [devices] - comma delimited list of devices to plot'
    print
    print 'Will attempt to create <output directory> if it does not exist.'
    sys.exit(1)

infilename = sys.argv[1]
outputdir = sys.argv[2]
device_list = None
if argc == 4:
    device_list = sys.argv[3]

# Make sure we can oping the file to read in data.
try:
    f = open(infilename, 'r')
except:
    print 'cannot open file: %s' % infilename
    sys.exit(1)

# Make sure we can open the files to write to.

if not exists(outputdir):
    try:
        # FIXME: Like I know why makedirs() fails...
        #makedirs(outputdir)
        system('mkdir -p %s' % outputdir)
    except:
        print 'cannot create directory "%s"' % outputdir
        sys.exit(2)

outputdir = realpath(outputdir)

# First identify the format.
format = 0
for line in f:
    c = line.strip().split()

    if len(c) == 12 and c[0] == 'Device:':
        # Device: rrqm/s wrqm/s r/s w/s rsec/s wsec/s avgrq-sz avgqu-sz await
        # svctm %util
        format = 1
        break;

if format == 0:
    print 'unrecognized iostat format, exiting...'
    sys.exit(1)
elif format == 1:
    c_rrqms = 1
    c_wrqms = 2
    c_rs = 3
    c_ws = 4
    c_rsecs = 5
    c_wsecs = 6
    c_avgrqsz = 7
    c_avgqusz = 8
    c_await = 9
    c_svctm = 10
    c_util = 11

# Read in the file and build up the dictionaries for each column of data from
# iostat.

d_x = [0]
d_rrqms = dict()
d_wrqms = dict()
d_rs = dict()
d_ws = dict()
d_rsecs = dict()
d_wsecs = dict()
d_avgrqsz = dict()
d_avgqusz = dict()
d_await = dict()
d_svctm = dict()
d_util = dict()

# Build a dict of dicts.  Why?  Because I fear hot swappable and nfs devices
# coming and going.

count = 0
for line in f:
    c = line.split()

    if len(c) != 12:
        continue

    if c[0] == 'Device:':
        count += 1
        d_x.append(count)
        continue

    # Filter for specific devices.
    if device_list is not None and c[0] not in device_list:
        continue

    # R doesn't like '!', '/' or '-' characters in the name, like how the cciss
    # driver and device mapper enumerates devices.  R will convert them to '.'
    # so just do it here so it's consistent everywhere.
    device = sub('/', '.', c[0])
    device = sub('-', '.', device)
    device = sub('!', '.', device)

    if device not in d_rrqms:
        d_rrqms[device] = list()
        d_wrqms[device] = list()
        d_rs[device] = list()
        d_ws[device] = list()
        d_rsecs[device] = list()
        d_wsecs[device] = list()
        d_avgrqsz[device] = list()
        d_avgqusz[device] = list()
        d_await[device] = list()
        d_svctm[device] = list()
        d_util[device] = list()

    d_rrqms[device].append(c[c_rrqms])
    d_wrqms[device].append(c[c_wrqms])
    d_rs[device].append(c[c_rs])
    d_ws[device].append(c[c_ws])

    # Misnomer, expecting sectors but converting to MB/s.
    d_rsecs[device].append(float(c[c_rsecs]) * 512.0 / 1024.0 / 1024.0)
    d_wsecs[device].append(float(c[c_wsecs]) * 512.0 / 1024.0 / 1024.0)

    # Convert from sectors to KB.
    d_avgrqsz[device].append(float(c[c_avgrqsz]) * 512.0 / 1024.0)
    d_avgqusz[device].append(c[c_avgqusz])
    d_await[device].append(c[c_await])
    d_svctm[device].append(c[c_svctm])
    d_util[device].append(c[c_util])
f.close()

# Create the R data frames.

data = {'elapsed_time': robjects.IntVector(d_x)}
dfx = r['data.frame'](**data)
 
d_rrqms = prep_data_frame(d_rrqms)
d_wrqms = prep_data_frame(d_wrqms)
d_rs = prep_data_frame(d_rs)
d_ws = prep_data_frame(d_ws)
d_rsecs = prep_data_frame(d_rsecs)
d_wsecs = prep_data_frame(d_wsecs)
d_avgrqsz = prep_data_frame(d_avgrqsz)
d_avgqusz = prep_data_frame(d_avgqusz)
d_await = prep_data_frame(d_await)
d_svctm = prep_data_frame(d_svctm)
d_util = prep_data_frame(d_util)

xmax = r.max(*dfx.rx('elapsed_time'))[0]

legend = get_legend(d_rrqms)

# Create charts for read/write request merges per second.
dfr = r['data.frame'](**d_rrqms)
dfw = r['data.frame'](**d_wrqms)

# Set the y-axis to the same scale between the read and write data so that it
# is easier to compare charts.
ymax_list = getymax(dfr, d_rrqms)
ymax_list.extend(getymax(dfw, d_wrqms))

y = gety(dfr, d_rrqms)
make_chart('rrqms', dfx.rx2('elapsed_time'), y, xmax, ymax_list, len(y),
           'Read Requests Merged', 'Number of Requests', legend)

y = gety(dfw, d_wrqms)
make_chart('wrqms', dfx.rx2('elapsed_time'), y, xmax, ymax_list, len(y),
           'Write Requests Merged', 'Number of Requests', legend)

# Create charts for reads/writes per second.
dfr = r['data.frame'](**d_rs)
dfw = r['data.frame'](**d_ws)

# Set the y-axis to the same scale between the read and write data so that it
# is easier to compare charts.
ymax_list = getymax(dfr, d_rs)
ymax_list.extend(getymax(dfw, d_ws))

y = gety(dfr, d_rs)
make_chart('rs', dfx.rx2('elapsed_time'), y, xmax, ymax_list, len(y),
           'Read I/O Requests', 'Number of Requests', legend)

y = gety(dfw, d_ws)
make_chart('ws', dfx.rx2('elapsed_time'), y, xmax, ymax_list, len(y),
           'Write I/O Requests', 'Number of Requests', legend)

# Create charts for MB reads/writes per second.
dfr= r['data.frame'](**d_rsecs)
dfw= r['data.frame'](**d_wsecs)

# Set the y-axis to the same scale between the read and write data so that it
# is easier to compare charts.
ymax_list = getymax(dfr, d_rsecs)
ymax_list.extend(getymax(dfw, d_wsecs))

y = gety(dfr, d_rsecs)
make_chart('rsec', dfx.rx2('elapsed_time'), y, xmax, ymax_list, len(y),
           'Read Throughput', 'Megabytes per Second', legend)

y = gety(dfw, d_wsecs)
make_chart('wsec', dfx.rx2('elapsed_time'), y, xmax, ymax_list, len(y),
           'Write Throughput', 'Megabytes per Second', legend)

df = r['data.frame'](**d_avgrqsz)
y = gety(df, d_avgrqsz)
ymax_list = getymax(df, d_avgrqsz)
make_chart('avgrqsz', dfx.rx2('elapsed_time'), y, xmax, ymax_list, len(y),
           'Average Request Size', 'Kilobytes', legend)

df = r['data.frame'](**d_avgqusz)
y = gety(df, d_avgqusz)
ymax_list = getymax(df, d_avgqusz)
make_chart('avgqusz', dfx.rx2('elapsed_time'), y, xmax, ymax_list, len(y),
           'Average Queue Length', 'Length', legend)

df = r['data.frame'](**d_await)
y = gety(df, d_await)
ymax_list = getymax(df, d_await)
make_chart('await', dfx.rx2('elapsed_time'), y, xmax, ymax_list, len(y),
           'Average Wait Time', 'Milliseconds', legend)

df = r['data.frame'](**d_svctm)
y = gety(df, d_svctm)
ymax_list = getymax(df, d_svctm)
make_chart('svctm', dfx.rx2('elapsed_time'), y, xmax, ymax_list, len(y),
           'Average Service Time', 'Milliseconds', legend)

df = r['data.frame'](**d_util)
y = gety(df, d_util)
ymax_list = getymax(df, d_util)
make_chart('util', dfx.rx2('elapsed_time'), y, xmax, [100], len(y),
           'Bandwidth Utilization', 'Percentage', legend)
